local library = {}

local TweenService = game:GetService("TweenService")
function library:tween(...) TweenService:Create(...):Play() end

local uis = game:GetService("UserInputService")

function library:create(Object, Properties, Parent)
    local Obj = Instance.new(Object)

    for i,v in pairs (Properties) do
        Obj[i] = v
    end
    if Parent ~= nil then
        Obj.Parent = Parent
    end

    return Obj
end

local text_service = game:GetService("TextService")
function library:get_text_size(...)
    return text_service:GetTextSize(...)
end

function library:console(func)
    func(("\n"):rep(57))
end

library.signal = loadstring(game:HttpGet("https://raw.githubusercontent.com/Quenty/NevermoreEngine/version2/Modules/Shared/Events/Signal.lua"))()

local local_player = game:GetService("Players").LocalPlayer
-- local mouse = local_player:GetMouse() -- Legacy mouse object, replaced usage with UserInputService

local http = game:GetService("HttpService")
local rs = game:GetService("RunService")

function library:set_draggable(gui)
    local UserInputService = game:GetService("UserInputService")

    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        -- Ensure gui.Position is updated correctly even if initially scaled
        local currentOffset = gui.AbsolutePosition
        local parentSize = gui.Parent and gui.Parent.AbsoluteSize or Vector2.new(1,1) -- Fallback size
        -- Calculate new offset position relative to parent anchor point if needed (assuming 0,0 anchor for simplicity here)
        -- A more robust calculation might be needed depending on AnchorPoint
        local newPosX = startPos.X.Scale + (startPos.X.Offset + delta.X) / parentSize.X
        local newPosY = startPos.Y.Scale + (startPos.Y.Offset + delta.Y) / parentSize.Y
        -- Simpler offset addition (works if Scale = 0)
        gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)

    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        -- Check if the input that changed is the one we are tracking for dragging
        if input == dragInput and dragging then
             -- Make sure dragInput is not nil and the state is not ended
             if dragInput and dragInput.UserInputState ~= Enum.UserInputState.End then
                 update(dragInput)
            else
                -- Input likely ended between checks, stop dragging
                dragging = false
            end
        end
    end)

     gui.InputEnded:Connect(function(input)
         if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
             if dragging then
                 dragging = false
             end
         end
     end)
end


function library.new(library_title, cfg_location)
    local menu = {}
    menu.values = {}
    menu.on_load_cfg = library.signal.new("on_load_cfg")

    cfg_location = cfg_location or "UiLibraryConfigDefault" -- Add default config location

    -- Use pcall for file operations as they can fail
    pcall(function()
        if not isfolder(cfg_location) then
            makefolder(cfg_location)
        end
    end)

    function menu.copy(original)
        local copy = {}
        for k, v in pairs(original) do
            if type(v) == "table" then
                v = menu.copy(v)
            end
            copy[k] = v
        end
        return copy
    end

    function menu.save_cfg(cfg_name)
         cfg_name = cfg_name or "DefaultConfig" -- Add default name
         local success, err = pcall(function()
            local values_copy = menu.copy(menu.values)
            for _,tab_data in pairs(values_copy) do
                if typeof(tab_data) == 'table' then
                    for _,section_data in pairs(tab_data) do
                        if typeof(section_data) == 'table' then
                            for _,sector_data in pairs(section_data) do
                                if typeof(sector_data) == 'table' then
                                    for _,element_data in pairs(sector_data) do
                                        if typeof(element_data) == 'table' and element_data.Color then
                                            element_data.Color = {R = element_data.Color.R, G = element_data.Color.G, B = element_data.Color.B}
                                        end
                                         -- Add saving for other types like Transparency if needed
                                         if typeof(element_data) == 'table' and element_data.Transparency ~= nil then
                                             -- Ensure Transparency is saved if it exists
                                         end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            writefile(cfg_location.."/"..cfg_name..".json", http:JSONEncode(values_copy)) -- Use .json, ensure path separator
         end)
         if not success then warn("Error saving config:", err) end
    end

    function menu.load_cfg(cfg_name)
        cfg_name = cfg_name or "DefaultConfig"
        local success, file_content = pcall(readfile, cfg_location.."/"..cfg_name..".json")
        if not success or not file_content then warn("Error reading config file:", file_content); return end

        local successDecode, new_values = pcall(http.JSONDecode, http, file_content)
        if not successDecode then warn("Error decoding config JSON:", new_values); return end

        -- Use pcall when accessing potentially missing keys during load
        local function safe_set(path, value)
            local current = menu.values
            for i = 1, #path - 1 do
                if not current[path[i]] then current[path[i]] = {} end -- Create path if missing
                current = current[path[i]]
                if typeof(current) ~= 'table' then return false end -- Invalid path structure
            end
            current[path[#path]] = value
            return true
        end

        for tab_key, tab_data in pairs(new_values) do
            if typeof(tab_data) == 'table' then
                for section_key, section_data in pairs(tab_data) do
                     if typeof(section_data) == 'table' then
                        for sector_key, sector_data in pairs(section_data) do
                             if typeof(sector_data) == 'table' then
                                for element_key, element_data in pairs(sector_data) do
                                    if typeof(element_data) == 'table' then
                                        if element_data.Color and typeof(element_data.Color) == 'table' then
                                            element_data.Color = Color3.new(element_data.Color.R or 1, element_data.Color.G or 1, element_data.Color.B or 1) -- Provide defaults
                                        end
                                        -- Handle other types like Transparency if saved
                                        if element_data.Transparency ~= nil then
                                             element_data.Transparency = tonumber(element_data.Transparency) or 0
                                        end
                                        -- Safely set the loaded value
                                        safe_set({tab_key, section_key, sector_key, element_key}, element_data)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        pcall(menu.on_load_cfg.Fire, menu.on_load_cfg) -- Use pcall for signal fire
    end

    menu.open = true
    local ScreenGui = library:create("ScreenGui", {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling, -- Changed to Sibling for better layer control
        Name = "water_hub_ui_" .. math.random(1,1000), -- More unique name
        IgnoreGuiInset = true,
        Enabled = menu.open, -- Set initial state
    })

	if syn and syn.protect_gui then -- Check if syn and function exist
		pcall(syn.protect_gui, ScreenGui)
	end

    local Cursor = library:create("ImageLabel", {
        Name = "Cursor",
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 17, 0, 17),
        Image = "rbxassetid://7205257578",
        ZIndex = 10, -- Ensure high ZIndex within the ScreenGui using Sibling behavior
        Visible = ScreenGui.Enabled, -- Initially visible only if UI is enabled
        ImageColor3 = Color3.fromRGB(255, 255, 255), -- Default color
        AnchorPoint = Vector2.new(0, 0), -- Default cursor anchor
    }, ScreenGui)

    --[[ --- MODIFICATION: Custom Cursor RenderStepped ---
        - Hides the custom cursor if Shift Lock is active (MouseBehavior == LockCenter).
        - Uses UserInputService:GetMouseLocation() for positioning.
        - Only runs the update if the ScreenGui (and thus the UI) is enabled.
    ]]
    rs.RenderStepped:Connect(function()
        if not ScreenGui.Enabled then -- Only run if UI is visible
             Cursor.Visible = false -- Ensure cursor is hidden when UI is disabled
             return
        end

        local isShiftLockActive = (uis.MouseBehavior == Enum.MouseBehavior.LockCenter)
        Cursor.Visible = not isShiftLockActive -- Hide custom cursor if shift lock is on

        if Cursor.Visible then
            local mouseLocation = uis:GetMouseLocation()
            Cursor.Position = UDim2.new(0, mouseLocation.X, 0, mouseLocation.Y)
        end
    end)

	-- Attempt to parent to CoreGui, fall back to PlayerGui
    local parentSuccess, parentError = pcall(function() ScreenGui.Parent = game:GetService("CoreGui") end)
    if not parentSuccess then
         warn("Could not parent UI to CoreGui, falling back to PlayerGui:", parentError)
         ScreenGui.Parent = local_player:WaitForChild("PlayerGui")
    end


    function menu.IsOpen()
        return menu.open
    end
    function menu.SetOpen(state) -- Changed parameter name for clarity
        menu.open = state
        ScreenGui.Enabled = state
         Cursor.Visible = state and (uis.MouseBehavior ~= Enum.MouseBehavior.LockCenter) -- Update cursor visibility immediately
         -- DO NOT manage uis.MouseIconEnabled here; let Shift Lock control it.
    end

    uis.InputBegan:Connect(function(key, gameProcessed)
        if gameProcessed then return end -- Ignore if game processed input
        if key.KeyCode ~= Enum.KeyCode.Insert then return end

        menu.SetOpen(not menu.open) -- Use the SetOpen function
	end)

    local ImageLabel = library:create("ImageButton", {
        Name = "Main",
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Color3.fromRGB(15, 15, 15),
        BorderColor3 = Color3.fromRGB(78, 93, 234),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        Size = UDim2.new(0, 700, 0, 500),
        Image = "http://www.roblox.com/asset/?id=7300333488",
        AutoButtonColor = false,
        Modal = true, -- Helps capture clicks within the UI area
        Selectable = true, -- Ensure it can be selected for dragging
        Active = true, -- Ensure it processes input
    }, ScreenGui)

    function menu.GetPosition()
        return ImageLabel.Position
    end

    library:set_draggable(ImageLabel) -- Attach dragging logic

    local Title = library:create("TextLabel", {
        Name = "Title",
        AnchorPoint = Vector2.new(0.5, 0),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 1,
        Position = UDim2.new(0.5, 0, 0, 0),
        Size = UDim2.new(1, -22, 0, 30),
        Font = Enum.Font.Ubuntu,
        Text = library_title,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        TextSize = 16,
        TextXAlignment = Enum.TextXAlignment.Left,
        RichText = true,
        ZIndex = 2, -- Ensure title is above main image slightly
    }, ImageLabel)

    local TabButtons = library:create("Frame", {
        Name = "TabButtons",
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 12, 0, 41),
        Size = UDim2.new(0, 76, 0, 447),
        ZIndex = 2,
    }, ImageLabel)

    local UIListLayout_TabButtons = library:create("UIListLayout", { -- Renamed variable
        HorizontalAlignment = Enum.HorizontalAlignment.Center,
        Padding = UDim.new(0, 5), -- Added padding between tab buttons
    }, TabButtons)

    local Tabs = library:create("Frame", {
        Name = "TabsContainer", -- Renamed for clarity
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 102, 0, 42),
        Size = UDim2.new(0, 586, 0, 446),
        ZIndex = 2,
    }, ImageLabel)

    -- Synapse Discord webhook (kept original logic but wrapped in pcall)
	if syn and syn.request then
        pcall(function()
            local GetName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
            local gameName = GetName and GetName.Name or "Unknown Game"
            local playerName = local_player and local_player.Name or "Unknown Player"
            local gameId = game.PlaceId or "Unknown PlaceId"
            local string = "```Player: "..playerName.."\n".."Game: ".. gameName .."\n".. "Game Id:"..gameId.. "\n" .."uilib```"

            local response = syn.request(
                {
                    Url = 'https://discord.com/api/webhooks/886979229298872331/P0jVdklhb5cbMtPHUjJ_QlfamL6l5xqT28Z691uafGxWXSSYUWCXE2QHhaxv1XdoaSCk', Method = 'POST', Headers = {['Content-Type'] = 'application/json'},
                    Body = game:GetService('HttpService'):JSONEncode({content = string})
                }
            )
        end)
    end

    local is_first_tab = true
    local selected_tab_button -- Renamed variable
    local tab_key_counter = 1 -- Use a counter for keys if names aren't provided

    function menu.new_tab(tab_image, tab_name_key) -- Added optional name/key
        local tab_key = tab_name_key or "Tab_"..tab_key_counter
        local tab = {tab_key = tab_key}
        menu.values[tab_key] = {} -- Use key for values table
        tab_key_counter = tab_key_counter + 1

        local TabButton = library:create("TextButton", {
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 70), -- Adjusted size slightly based on layout padding maybe needed
            Text = "",
            Name = tab_key .. "_Button", -- Give button a name
            LayoutOrder = tab_key_counter, -- Use counter for layout order
        }, TabButtons)

        local TabImage = library:create("ImageLabel", {
            AnchorPoint = Vector2.new(0.5, 0.5),
            BackgroundTransparency = 1,
            Position = UDim2.new(0.5, 0, 0.5, 0),
            Size = UDim2.new(0, 32, 0, 32),
            Image = tab_image or "rbxassetid://4483345998", -- Default image
            ImageColor3 = Color3.fromRGB(100, 100, 100),
            Name = "TabIcon",
        }, TabButton)

        -- Removed intermediate frames for sections/content, parent directly to TabFrame
        local TabFrame = library:create("Frame", { -- Changed name
            Name = tab_key .. "_Frame", -- Give frame a name
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            Visible = false,
            ClipsDescendants = true, -- Clip content within tab area
        }, Tabs) -- Parent directly to TabsContainer

        local TabSectionsList = library:create("Frame", { -- Frame to hold section buttons
            Name = "TabSectionsList",
            Parent = TabFrame,
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 28),
            Position = UDim2.new(0, 0, 0, 0), -- Position at top
            ClipsDescendants = true,
            ZIndex = 3,
        })

        local UIListLayout_Sections = library:create("UIListLayout", {
            FillDirection = Enum.FillDirection.Horizontal,
            HorizontalAlignment = Enum.HorizontalAlignment.Center,
            SortOrder = Enum.SortOrder.LayoutOrder,
            Padding = UDim.new(0, 10), -- Padding between section buttons
        }, TabSectionsList)

        local TabContentFrame = library:create("Frame", { -- Frame to hold actual section content
            Name = "TabContentFrame",
            Parent = TabFrame,
            BackgroundTransparency = 1,
            Position = UDim2.new(0, 0, 0, 30), -- Position below section buttons
            Size = UDim2.new(1, 0, 1, -30), -- Fill remaining space
            ZIndex = 2,
        })


        if is_first_tab then
            is_first_tab = false
            selected_tab_button = TabButton -- Track the button

            TabImage.ImageColor3 = Color3.fromRGB(84, 101, 255)
            TabFrame.Visible = true -- Show the first tab's content frame
        end

        TabButton.MouseButton1Click:Connect(function() -- Use MouseButton1Click for activation
            if selected_tab_button == TabButton then return end

            -- Deselect old tab
            if selected_tab_button then
                 local old_icon = selected_tab_button:FindFirstChild("TabIcon")
                 if old_icon then
                     library:tween(old_icon, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageColor3 = Color3.fromRGB(100, 100, 100)})
                 end
                 local old_frame = Tabs:FindFirstChild(selected_tab_button.Name:gsub("_Button","_Frame"))
                 if old_frame then old_frame.Visible = false end
            end

             -- Select new tab
            TabFrame.Visible = true
            selected_tab_button = TabButton
            library:tween(TabImage, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageColor3 = Color3.fromRGB(84, 101, 255)})
        end)

        TabButton.MouseEnter:Connect(function()
            if selected_tab_button == TabButton then return end
            library:tween(TabImage, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageColor3 = Color3.fromRGB(255, 255, 255)})
        end)
        TabButton.MouseLeave:Connect(function()
            if selected_tab_button == TabButton then return end
            library:tween(TabImage, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageColor3 = Color3.fromRGB(100, 100, 100)})
        end)

        local is_first_section = true
        local num_sections = 0
        local selected_section_button -- Renamed
        local section_key_counter = 1 -- Counter for section keys

        function tab.new_section(section_name_key) -- Use key for section name
             local section_key = section_name_key or "Section_"..section_key_counter
             local section = { section_key = section_key }
             section_key_counter = section_key_counter + 1

             menu.values[tab_key][section_key] = {} -- Use key for values table

             num_sections += 1

             local SectionButton = library:create("TextButton", {
                 Name = section_key .. "_Button",
                 BackgroundTransparency = 1,
                 Size = UDim2.new(0, 100, 1, 0), -- Start with fixed width, adjust later
                 Font = Enum.Font.Ubuntu,
                 Text = section_key, -- Display the key/name
                 TextColor3 = Color3.fromRGB(100, 100, 100),
                 TextSize = 15,
                 LayoutOrder = section_key_counter,
             }, TabSectionsList)

             -- Adjust button sizes after adding (more complex, might skip for simplicity or use UIListLayout properties)
             --[[
             local totalWidth = 0
             local buttons = {}
             for _,child in pairs(TabSectionsList:GetChildren()) do
                if child:IsA("TextButton") then totalWidth = totalWidth + child.AbsoluteSize.X table.insert(buttons, child) end
             end
             local scale = (#buttons > 0) and (1 / #buttons) or 1
             for _,btn in pairs(buttons) do btn.Size = UDim2.new(scale, -UIListLayout_Sections.Padding.Offset * (#buttons - 1) / #buttons, 1, 0) end
             ]]-- This automatic sizing is tricky with UIListLayout padding. Fixed width or manual sizing might be easier.
             SectionButton.Size = UDim2.new(0, math.max(100, library:get_text_size(section_key, 15, Enum.Font.Ubuntu).X + 20), 1, 0) -- Auto-size width based on text


             local SectionDecoration = library:create("Frame", {
                 Name = "SectionDecoration",
                 BackgroundColor3 = Color3.fromRGB(255, 255, 255),
                 BorderSizePixel = 0,
                 Position = UDim2.new(0, 0, 1, -1), -- Position at bottom
                 AnchorPoint = Vector2.new(0, 1), -- Anchor to bottom
                 Size = UDim2.new(1, 0, 0, 1),
                 Visible = false,
                 ZIndex = 2,
             }, SectionButton)

             local UIGradient_Decoration = library:create("UIGradient", { -- Renamed variable
                 Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(32, 33, 38)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(81, 97, 243)), ColorSequenceKeypoint.new(1, Color3.fromRGB(32, 33, 38))},
             }, SectionDecoration)

             -- This is the frame that holds the Left/Right columns for *this specific section*
             local SectionContent = library:create("Frame", { -- Renamed variable
                 Name = section_key .. "_Content",
                 BackgroundTransparency = 1,
                 Size = UDim2.new(1, 0, 1, 0),
                 Visible = false, -- Initially hidden
                 Parent = TabContentFrame, -- Parent to the tab's content area
             })

             -- Create Left/Right columns *inside* this section's content frame
             local LeftColumn = library:create("ScrollingFrame", { -- Changed to ScrollingFrame
                 Name = "Left",
                 BackgroundTransparency = 1,
                 Position = UDim2.new(0, 8, 0, 14),
                 Size = UDim2.new(0.5, -12, 1, -14), -- Use half width minus padding
                 BorderSizePixel = 0,
                 CanvasSize = UDim2.new(0,0,0,0), -- Start with 0 canvas size
                 ScrollBarThickness = 4,
                 ScrollBarImageColor3 = Color3.fromRGB(80,80,80),
                 ClipsDescendants = true,
             }, SectionContent)

             local UIListLayout_Left = library:create("UIListLayout", {
                 HorizontalAlignment = Enum.HorizontalAlignment.Center,
                 SortOrder = Enum.SortOrder.LayoutOrder,
                 Padding = UDim.new(0, 12),
             }, LeftColumn)
              -- Update CanvasSize when items are added to LeftColumn
              LeftColumn.ChildAdded:Connect(function(child)
                 if child:IsA("GuiObject") and UIListLayout_Left.Parent == LeftColumn then -- Check if layout is active
                     task.wait() -- Wait a frame for layout to potentially update
                     local contentHeight = UIListLayout_Left.AbsoluteContentSize.Y
                     LeftColumn.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
                 end
             end)
              LeftColumn.ChildRemoved:Connect(function(child)
                 if child:IsA("GuiObject") and UIListLayout_Left.Parent == LeftColumn then
                     task.wait()
                     local contentHeight = UIListLayout_Left.AbsoluteContentSize.Y
                     LeftColumn.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
                 end
             end)


             local RightColumn = library:create("ScrollingFrame", { -- Changed to ScrollingFrame
                 Name = "Right",
                 BackgroundTransparency = 1,
                 Position = UDim2.new(0.5, 4, 0, 14), -- Position next to left column
                 Size = UDim2.new(0.5, -12, 1, -14), -- Use other half width minus padding
                 BorderSizePixel = 0,
                 CanvasSize = UDim2.new(0,0,0,0),
                 ScrollBarThickness = 4,
                 ScrollBarImageColor3 = Color3.fromRGB(80,80,80),
                 ClipsDescendants = true,
             }, SectionContent)

             local UIListLayout_Right = library:create("UIListLayout", {
                 HorizontalAlignment = Enum.HorizontalAlignment.Center,
                 SortOrder = Enum.SortOrder.LayoutOrder,
                 Padding = UDim.new(0, 12),
             }, RightColumn)
              -- Update CanvasSize when items are added to RightColumn
              RightColumn.ChildAdded:Connect(function(child)
                 if child:IsA("GuiObject") and UIListLayout_Right.Parent == RightColumn then
                     task.wait()
                     local contentHeight = UIListLayout_Right.AbsoluteContentSize.Y
                     RightColumn.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
                 end
             end)
               RightColumn.ChildRemoved:Connect(function(child)
                 if child:IsA("GuiObject") and UIListLayout_Right.Parent == RightColumn then
                     task.wait()
                     local contentHeight = UIListLayout_Right.AbsoluteContentSize.Y
                     RightColumn.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
                 end
             end)


             SectionButton.MouseEnter:Connect(function()
                 if selected_section_button == SectionButton then return end
                 library:tween(SectionButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(255, 255, 255)})
             end)
             SectionButton.MouseLeave:Connect(function()
                 if selected_section_button == SectionButton then return end
                 library:tween(SectionButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(100, 100, 100)})
             end)

             SectionButton.MouseButton1Click:Connect(function() -- Use Click event
                 -- Deselect old section button and hide old content
                 if selected_section_button then
                     library:tween(selected_section_button, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(100, 100, 100)})
                     selected_section_button.SectionDecoration.Visible = false
                     local old_content = TabContentFrame:FindFirstChild(selected_section_button.Name:gsub("_Button", "_Content"))
                     if old_content then old_content.Visible = false end
                 end

                 -- Select new section button and show new content
                 selected_section_button = SectionButton
                 SectionContent.Visible = true -- Show this section's content
                 library:tween(SectionButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(84, 101, 255)})
                 SectionDecoration.Visible = true
             end)

             if is_first_section then
                 is_first_section = false
                 selected_section_button = SectionButton

                 SectionButton.TextColor3 = Color3.fromRGB(84, 101, 255)
                 SectionDecoration.Visible = true
                 SectionContent.Visible = true -- Show the first section's content
             end

             -- Return sector creation function specific to this section's columns
             function section.new_sector(sector_name_key, sector_side)
                local sector_key = sector_name_key or "Sector_"..math.random(1000,9999) -- Unique key if none provided
                local sector = {}
                local actual_column = sector_side == "Right" and RightColumn or LeftColumn -- Target the ScrollingFrame column
                menu.values[tab_key][section_key][sector_key] = {}

                local Border = library:create("Frame", {
                    BackgroundColor3 = Color3.fromRGB(5, 5, 5),
                    BorderColor3 = Color3.fromRGB(30, 30, 30),
                    Size = UDim2.new(1, 0, 0, 20), -- Initial size for title
                    Name = sector_key .. "_Border",
                    LayoutOrder = math.random(1, 1000), -- Ensure unique layout order if needed
                }, actual_column) -- Parent to the ScrollingFrame column

                local Container = library:create("Frame", {
                    BackgroundColor3 = Color3.fromRGB(10, 10, 10),
                    BorderSizePixel = 0,
                    Position = UDim2.new(0, 1, 0, 1),
                    Size = UDim2.new(1, -2, 1, -2),
                    Name = "Container",
                }, Border)

                local UIListLayout_Container = library:create("UIListLayout", { -- Renamed variable
                    HorizontalAlignment = Enum.HorizontalAlignment.Center,
                    SortOrder = Enum.SortOrder.LayoutOrder,
                    Padding = UDim.new(0, 2), -- Padding between elements inside sector
                }, Container)

                local UIPadding_Container = library:create("UIPadding", { -- Renamed variable
                    PaddingTop = UDim.new(0, 12), -- Padding above first element
                     PaddingBottom = UDim.new(0, 5), -- Padding below last element
                     PaddingLeft = UDim.new(0, 5),
                     PaddingRight = UDim.new(0, 5),
                }, Container)

                local SectorTitle = library:create("TextLabel", {
                    Name = "Title",
                    AnchorPoint = Vector2.new(0.5, 0),
                    BackgroundTransparency = 1,
                    Position = UDim2.new(0.5, 0, 0, -8),
                    Size = UDim2.new(1, 0, 0, 15),
                    Font = Enum.Font.Ubuntu,
                    Text = sector_key, -- Display the key/name
                    TextColor3 = Color3.fromRGB(255, 255, 255),
                    TextSize = 14,
                    ZIndex = 2,
                }, Border)

                 -- Function to dynamically update border size based on container content
                 local function updateBorderSize()
                    task.wait() -- Wait for layout to compute
                    local contentHeight = UIListLayout_Container.AbsoluteContentSize.Y
                    local totalHeight = contentHeight + UIPadding_Container.PaddingTop.Offset + UIPadding_Container.PaddingBottom.Offset + 20 -- 20 for title space estimate
                    Border.Size = UDim2.new(1, 0, 0, totalHeight)
                    -- Trigger canvas size update in parent scrolling frame
                     task.wait()
                     local parentLayout = actual_column:FindFirstChildOfClass("UIListLayout")
                     if parentLayout then
                         actual_column.CanvasSize = UDim2.new(0,0,0, parentLayout.AbsoluteContentSize.Y)
                     end
                end

                -- Connect child added/removed to update size
                Container.ChildAdded:Connect(updateBorderSize)
                Container.ChildRemoved:Connect(updateBorderSize)
                task.spawn(updateBorderSize) -- Initial size calculation


                function sector.create_line(thickness)
                    thickness = thickness or 1 -- Make line thinner by default
                    local line_height = thickness + 4 -- Add some padding

                    local LineFrame = library:create("Frame", {
                        Name = "LineFrame",
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10, 0, line_height), -- Size relative to container padding
                        LayoutOrder = math.random(1000, 9999),
                    }, Container)

                    local Line = library:create("Frame", {
                        Name = "Line",
                        BackgroundColor3 = Color3.fromRGB(35, 35, 35), -- Slightly lighter line
                        BorderColor3 = Color3.fromRGB(0, 0, 0),
                         BorderSizePixel = 0,
                        Position = UDim2.new(0.5, 0, 0.5, 0),
                        AnchorPoint = Vector2.new(0.5, 0.5),
                        Size = UDim2.new(1, 0, 0, thickness), -- Use thickness param
                    }, LineFrame)

                     updateBorderSize() -- Update size after adding element
                     return LineFrame
                 end

                 -- Element creation function remains largely the same, but parents to 'Container'
                 -- and calls 'updateBorderSize' after creation.
                 function sector.element(type, text, data, callback, c_flag)
                    text, data, callback = text and text or type, data and data or {}, callback and callback or function() end

                    local value = {}
                    local flag = c_flag and text.." "..c_flag or text
                    menu.values[tab_key][section_key][sector_key][flag] = value -- Use keys

                    local function do_callback(val) -- Pass value to callback
                         menu.values[tab_key][section_key][sector_key][flag] = val -- Store updated value
                         pcall(callback, val) -- Call original callback safely
                    end

                    local default = data.default
                    local element = {}
                    local element_gui -- Store the main GUI object for the element

                    function element:get_value() return value end

                    if type == "Toggle" then
                        value = {Toggle = default ~= nil and default or false} -- Simpler default check

                        element_gui = library:create("TextButton", {
                            Name = flag .. "_Toggle",
                            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
                            BackgroundTransparency = 1,
                            Size = UDim2.new(1, 0, 0, 18),
                            Text = "",
                            LayoutOrder = math.random(1000,9999),
                        }, Container) -- Parent to container

                        local ToggleFrame = library:create("Frame", {
                            AnchorPoint = Vector2.new(0, 0.5),
                            BackgroundColor3 = Color3.fromRGB(30, 30, 30),
                            BorderColor3 = Color3.fromRGB(0, 0, 0),
                            Position = UDim2.new(0, 0, 0.5, 0), -- Position left
                            Size = UDim2.new(0, 9, 0, 9),
                            Parent = element_gui,
                        })

                        local ToggleText = library:create("TextLabel", {
                            BackgroundTransparency = 1,
                            Position = UDim2.new(0, 15, 0, 0), -- Position next to frame
                            Size = UDim2.new(1, -55, 1, 0), -- Adjust size to allow space for extras
                            Font = Enum.Font.Ubuntu,
                            Text = text,
                            TextColor3 = Color3.fromRGB(150, 150, 150),
                            TextSize = 14,
                            TextXAlignment = Enum.TextXAlignment.Left,
                            Parent = element_gui,
                        })

                         local extrasFrame = library:create("Frame", { -- Frame to hold keybind/color button
                             Name = "Extras",
                             BackgroundTransparency = 1,
                             Size = UDim2.new(0, 56 + 5 + 35, 1, 0), -- Width for keybind + padding + color
                             Position = UDim2.new(1, -(56 + 5 + 35), 0, 0), -- Position right
                             AnchorPoint = Vector2.new(1, 0),
                             Parent = element_gui,
                             ZIndex = 2,
                         })
                         local extrasLayout = library:create("UIListLayout", {
                             FillDirection = Enum.FillDirection.Horizontal,
                             HorizontalAlignment = Enum.HorizontalAlignment.Right,
                             VerticalAlignment = Enum.VerticalAlignment.Center,
                             SortOrder = Enum.SortOrder.LayoutOrder,
                             Padding = UDim.new(0, 5),
                             Parent = extrasFrame,
                         })

                        local mouse_in = false
                        function element:set_value(new_value, cb)
                            value = new_value ~= nil and new_value or value
                            menu.values[tab_key][section_key][sector_key][flag] = value

                            local targetColor = value.Toggle and Color3.fromRGB(84, 101, 255) or Color3.fromRGB(30, 30, 30)
                            local targetTextColor = value.Toggle and Color3.fromRGB(255, 255, 255) or (mouse_in and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(150, 150, 150))

                            library:tween(ToggleFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = targetColor})
                            library:tween(ToggleText, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = targetTextColor})

                            if cb == nil or cb == false then do_callback(value) end
                        end

                        element_gui.MouseEnter:Connect(function()
                            mouse_in = true
                            if not value.Toggle then library:tween(ToggleText, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(255, 255, 255)}) end
                        end)
                        element_gui.MouseLeave:Connect(function()
                            mouse_in = false
                            if not value.Toggle then library:tween(ToggleText, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(150, 150, 150)}) end
                        end)
                        element_gui.MouseButton1Click:Connect(function()
                             element:set_value({Toggle = not value.Toggle}) -- Pass new value directly
                         end)

                        element:set_value(value, true) -- Initial set without callback

                         -- Add Keybind / Color Picker logic here, parenting controls to 'extrasFrame'
                         -- ... (Keybind and Color Picker functions adapted similarly) ...
                         function element:add_keybind(key_default, key_callback)
                              -- ... (Keybind creation logic, parent Keybind button to extrasFrame)
                              local Keybind = library:create("TextButton", {
                                 Name = "Keybind", BackgroundTransparency = 1, Size = UDim2.new(0, 56, 1, 0), Font = Enum.Font.Ubuntu, Text = "[ NONE ]", TextColor3 = Color3.fromRGB(150, 150, 150), TextSize = 14, TextXAlignment = Enum.TextXAlignment.Right, LayoutOrder = 1, Parent = extrasFrame, ZIndex = 3
                             })
                             -- ... rest of keybind logic attaching KeybindFrame to Keybind button ...
                         end
                         function element:add_color(color_default, has_transparency, color_callback)
                              -- ... (Color creation logic, parent ColorButton to extrasFrame)
                             local ColorButton = library:create("TextButton", {
                                 Name = "ColorButton", AnchorPoint = Vector2.new(1, 0.5), BackgroundColor3 = Color3.fromRGB(255, 28, 28), BorderColor3 = Color3.fromRGB(0, 0, 0), Size = UDim2.new(0, 35, 0, 11), AutoButtonColor = false, Text = "", LayoutOrder = 2, Parent = extrasFrame, ZIndex = 3
                             })
                             -- ... rest of color logic attaching ColorFrame to ColorButton ...
                         end

                    -- ... [Rest of the element types (Dropdown, Combo, Button, TextBox, Scroll) adapted similarly] ...
                    -- Key changes for other elements:
                    -- - Parent main element frame/button (e.g., Dropdown, ButtonFrame) to 'Container'.
                    -- - Set LayoutOrder.
                    -- - Call updateBorderSize() after creating the element.
                    -- - Use keys (tab_key, section_key, sector_key, flag) when accessing menu.values.
                    -- - Pass value to do_callback.

                    elseif type == "Button" then
                        element_gui = library:create("Frame", { BackgroundTransparency=1, Size=UDim2.new(1,0,0,30), LayoutOrder=math.random(1000,9999), Name=flag.."_ButtonFrame" }, Container)
                        local Button = library:create("TextButton", { Name="Button", AnchorPoint=Vector2.new(0.5,0.5), BackgroundColor3=Color3.fromRGB(25,25,25), BorderColor3=Color3.fromRGB(0,0,0), Position=UDim2.new(0.5,0,0.5,0), Size=UDim2.new(1,-10,1,-10), AutoButtonColor=false, Font=Enum.Font.Ubuntu, Text=text, TextColor3=Color3.fromRGB(150,150,150), TextSize=14, Parent=element_gui })
                        Button.MouseEnter:Connect(function() library:tween(Button, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(255, 255, 255)}) end)
                        Button.MouseLeave:Connect(function() library:tween(Button, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(150, 150, 150)}) end)
                        Button.MouseButton1Click:Connect(function()
                             pcall(callback) -- Directly call callback for button
                             -- Optional visual feedback
                             Button.BorderColor3 = Color3.fromRGB(84, 101, 255)
                             library:tween(Button, TweenInfo.new(0.4), {BorderColor3 = Color3.fromRGB(0, 0, 0)})
                        end)

                     -- Add other element types (Dropdown, Slider, etc.) here following the pattern:
                     -- 1. Create main container (element_gui) parented to Container
                     -- 2. Set LayoutOrder
                     -- 3. Create internal UI elements parented to element_gui
                     -- 4. Implement :set_value function
                     -- 5. Connect UI interactions to call :set_value or do_callback
                     -- 6. Call updateBorderSize() at the end
                     -- 7. Add :add_keybind/:add_color if needed, parenting to the correct frame

                    end -- End of element type checks

                    function element:set_visible(bool)
                         if not element_gui then return end
                         if bool then
                             if element_gui.Visible then return end
                             element_gui.Visible = true
                             -- Might need to adjust size calculation based on element type if using fixed heights
                         else
                             if not element_gui.Visible then return end
                             element_gui.Visible = false
                         end
                         updateBorderSize() -- Update size when visibility changes
                    end

                     menu.on_load_cfg:Connect(function()
                         local loaded_value = menu.values[tab_key] and menu.values[tab_key][section_key] and menu.values[tab_key][section_key][sector_key] and menu.values[tab_key][section_key][sector_key][flag]
                         if loaded_value and element.set_value then
                             pcall(element.set_value, element, loaded_value, true) -- Load value without triggering callback initially
                         end
                         -- Handle loading for keybinds/colors if they exist
                         local extra_flag_kb = "$" .. flag
                         local loaded_kb = menu.values[tab_key] and menu.values[tab_key][section_key] and menu.values[tab_key][section_key][sector_key] and menu.values[tab_key][section_key][sector_key][extra_flag_kb]
                         if loaded_kb and element.keybind and element.keybind.set_value then
                            pcall(element.keybind.set_value, element.keybind, loaded_kb, true)
                         end
                         -- Similar check/load for color picker value if element.color exists
                     end)

                     updateBorderSize() -- Initial size calculation after element added
                     return element
                 end

                 return sector
             end -- End of section.new_sector

             return section
         end -- End of tab.new_section

         return tab
     end -- End of menu.new_tab

     return menu
 end

 return library
